open Nes
open Common
open Utils
open Model

let display_warnings warnings =
  let open Html in
  let display_times n =
    if n = 1 then []
    else [txt " ("; txt (Int.to_english_string_times n); txt ")"]
  in
  let rec display_sets = function
    | [] -> []
    | (None, n) :: tl ->
      ([txt "standalone"] @ display_times n) :: display_sets tl
    | (Some set, n) :: tl ->
      ([txt "in “"; Formatters.Set.name' set; txt "”"] @ display_times n) :: display_sets tl
  in
  let rec format_set_list = function
    (* If the warning Duplicate_tune has been logged, the list of sets,
       and hence of html nodes generated by [display_sets] above is never empty *)
    | [] -> assert false
    | [hd] -> hd @ [txt "."]
    | hd :: tl -> hd @ [txt ", "] @ format_set_list tl
  in
  let display_warning warning =
    match warning with
    | Book.Empty ->
      li [txt "This book is empty"]
    | Book.Duplicate_set set ->
      li [txt "Set “"; Formatters.Set.name' set; txt "” appears several times in this book."]
    | Book.Duplicate_tune (tune, sets_opt) ->
      li
        (
          txt "Tune “" :: Formatters.Tune.name' tune :: txt "” appears several times: " :: (display_sets sets_opt |> format_set_list)
        )
    | Book.Set_dance_kind_mismatch (set, dance) ->
      li [txt "Set “"; Formatters.Set.name' set; txt "” does not have the same kind as its associated dance “"; Formatters.Dance.name' dance; txt "”."]
  in
  List.map display_warning warnings

let table_contents ~this_id contents =
  (* We need to find the index of each part of the book in the whole book. They
     aren't just the index in the list because some elements are not actually
     viewable standalone. *)
  let contents =
    let next_index = ref 0 in
    List.map
      (fun page ->
        match Components.Context_links.book_page_to_any page with
        | None -> (-1, page)
        | Some _ -> let index = !next_index in incr next_index; (index, page)
      )
      contents
  in
  let open Html in
  tablex
    ~a: [a_class ["table"; "table-striped"; "table-hover"; "table-borderless"; "my-2"]]
    ~thead: (
      thead
        ~a: [a_class ["table-primary"]]
        [
          tr
            [
              th [txt "Type"];
              th [txt "Name"];
              th [txt "Kind"];
              th [txt "Music by"];
            ]
        ]
    )
    [
      tbody
        (
          List.map
            (fun (index, page) ->
              let context = S.const @@ Endpoints.Page.in_book this_id index in
              (* on non-viewable pages, index = -1 *)
              match page with
              | Book.Part title ->
                Any_result.make_part_result
                  ~prefix: [td [txt "Part"]]
                  title
              | Book.Dance (dance, Dance_only) ->
                Any_result.make_dance_result
                  ~prefix: [td [txt "Dance"]]
                  ~context
                  dance
              | Book.Dance (dance, Dance_versions versions_and_params) ->
                Any_result.make_dance_plus_versions_result
                  ~prefix: [td [txt "Dance"; Any_result.details [txt (if NEList.is_singleton versions_and_params then "+Tune" else "+Tunes")]]]
                  ~context
                  dance
                  versions_and_params
              | Book.Dance (dance, Dance_set (set, params)) ->
                Any_result.make_dance_plus_set_result
                  ~prefix: [td [txt "Dance"; Any_result.details [txt "+Set"]]]
                  dance
                  set
                  ~set_params: params
              | Book.Versions versions_and_params ->
                Any_result.make_versions_result
                  ~prefix: [td [txt @@ if NEList.is_singleton versions_and_params then "Tune" else "Tunes"]]
                  versions_and_params
              | Book.Set (set, params) ->
                Any_result.make_set_result
                  ~prefix: [td [txt "Set"]]
                  ~context
                  ~params
                  set
            )
            contents
        )
    ]

open Html

let view context id =
  Main_page.madge_call_or_404 (Book Get) id @@ fun book ->
  Page.make'
    ~parent_title: "Book"
    ~before_title: [
      Components.Context_links.make_and_render
        ?context
        ~this_page: (Endpoints.Page.href_book id)
        (lwt @@ Any.book book);
    ]
    ~title: (lwt @@ NEString.to_string @@ Book.title' book)
    ~subtitles: [Formatters.Book.date_and_editors' book]
    ~share: (Book book)
    ~actions: [
      lwt [
        Button.make
          ~label: "Download PDF"
          ~icon: (Other File_pdf)
          ~onclick: (fun _ -> ignore <$> Book_download_dialog.create_and_open book)
          ~dropdown: true
          ();
      ];
      (
        match%lwt Permission.can_update_private book with
        | None -> lwt_nil
        | Some _ ->
          lwt [
            Button.make_a
              ~label: "Edit"
              ~icon: (Action Edit)
              ~href: (S.const @@ Endpoints.Page.(href Book_edit) id)
              ~dropdown: true
              ();
          ]
      );
      (
        match%lwt Permission.can_delete_private book with
        | None -> lwt_nil
        | Some _ ->
          lwt [
            Action.delete
              ~model: "book"
              ~onclick: (fun () -> Madge_client.call Endpoints.Api.(route @@ Book Delete) (Entry.id book))
              ();
          ]
      );
      (lwt @@ Option.map_to_list (Action.scddb Publication) (Book.scddb_id' book));
    ]
    [
      R.div (
        S.from' [] @@
          match%lwt Book.warnings book with
          | [] -> lwt_nil
          | warnings -> lwt [div ~a: [a_class ["alert"; "alert-warning"]] [ul ~a: [a_class ["mb-0"]] (display_warnings warnings)]]
      );
      div [
        h3 [txt "Contents"];
        R.div (
          S.from' (Tables.placeholder ()) @@
            let%lwt contents = Book.contents' book in
            lwt [table_contents ~this_id: id contents]
        )
      ];
    ]
