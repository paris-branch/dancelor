open Nes
open Common
open Utils
open Model

let display_warnings warnings =
  let open Html in
  let display_times n =
    if n = 1 then []
    else [txt " ("; txt (Int.to_english_string_times n); txt ")"]
  in
  let rec display_sets = function
    | [] -> []
    | (None, n) :: tl ->
      ([txt "standalone"] @ display_times n) :: display_sets tl
    | (Some set, n) :: tl ->
      ([txt "in “"; Formatters.Set.name' set; txt "”"] @ display_times n) :: display_sets tl
  in
  let rec format_set_list = function
    (* If the warning Duplicate_tune has been logged, the list of sets,
       and hence of html nodes generated by [display_sets] above is never empty *)
    | [] -> assert false
    | [hd] -> hd @ [txt "."]
    | hd :: tl -> hd @ [txt ", "] @ format_set_list tl
  in
  let display_warning warning =
    match warning with
    | Book.Empty ->
      li [txt "This book is empty"]
    | Book.Duplicate_set set ->
      li [txt "Set “"; Formatters.Set.name' set; txt "” appears several times in this book."]
    | Book.Duplicate_tune (tune, sets_opt) ->
      li
        (
          txt "Tune “" :: Formatters.Tune.name' tune :: txt "” appears several times: " :: (display_sets sets_opt |> format_set_list)
        )
    | Book.Set_dance_kind_mismatch (set, dance) ->
      li [txt "Set “"; Formatters.Set.name' set; txt "” does not have the same kind as its associated dance “"; Formatters.Dance.name' dance; txt "”."]
  in
  List.map display_warning warnings

let table_contents ~this_id contents =
  (* We need to find the index of each part of the book in the whole book. They
     aren't just the index in the list because some elements are not actually
     viewable standalone. *)
  let contents =
    let next_index = ref 0 in
    List.map
      (fun page ->
        match Components.Context_links.book_page_to_any page with
        | None -> (-1, page)
        | Some _ -> let index = !next_index in incr next_index; (index, page)
      )
      contents
  in
  let open Html in
  tablex
    ~a: [a_class ["table"; "table-striped"; "table-hover"; "table-borderless"; "my-2"]]
    ~thead: (
      thead
        ~a: [a_class ["table-primary"]]
        [
          tr
            [
              th [txt "Type"];
              th [txt "Name"];
              th [txt "Kind"];
              th [txt "Music by"];
            ]
        ]
    )
    [
      tbody
        (
          List.map
            (fun (index, page) ->
              let context = S.const @@ Endpoints.Page.in_book this_id index in
              (* on non-viewable pages, index = -1 *)
              match page with
              | Book.Part title ->
                (
                  Result_row.to_clickable_row @@
                    Result_row.make [
                      td [txt "Part"];
                      td ~a: [a_colspan 3] [txt @@ NEString.to_string title];
                    ]
                )
              | Book.Dance (dance, Dance_only) ->
                (
                  Tables.clickable_row [
                    lwt [txt "Dance"];
                    lwt [Formatters.Dance.name' ~context dance];
                    lwt [txt @@ Kind.Dance.to_string @@ Dance.kind' dance];
                    lwt [];
                  ]
                )
              | Book.Dance (dance, Dance_versions versions_and_params) ->
                (
                  Tables.clickable_row [
                    lwt [
                      txt "Dance";
                      br ();
                      txt (if NEList.is_singleton versions_and_params then "+Tune" else "+Tunes");
                    ];
                    lwt [
                      Formatters.Dance.name' ~context dance;
                      br ();
                      small ~a: [a_class ["opacity-50"]] [
                        txt (if NEList.is_singleton versions_and_params then "Tune: " else "Tunes: ");
                        Formatters.Version.names_disambiguations_and_sources' ~name_links: true versions_and_params
                      ];
                    ];
                    lwt [txt @@ Kind.Dance.to_string @@ Dance.kind' dance];
                    lwt [Formatters.Version.composers_and_arrangers' ~short: true versions_and_params]
                  ]
                )
              | Book.Dance (dance, Dance_set (set, params)) ->
                (
                  Tables.clickable_row [
                    lwt [txt "Dance"; br (); txt "+Set"];
                    lwt [
                      Formatters.Dance.name' ~context dance;
                      br ();
                      small ~a: [a_class ["opacity-50"]] [txt "Set: "; Formatters.Set.name' ~link: true ~params set];
                      br ();
                      small ~a: [a_class ["opacity-50"]] [Formatters.Set.tunes' ~link: true set];
                    ];
                    lwt [txt @@ Kind.Dance.to_string @@ Dance.kind' dance];
                    lwt [Formatters.Set.conceptors' ~short: true ~params set];
                  ]
                )
              | Book.Versions versions_and_params ->
                (
                  Tables.clickable_row [
                    lwt [txt @@ if NEList.is_singleton versions_and_params then "Tune" else "Tunes"];
                    lwt [Formatters.Version.names_disambiguations_and_sources' ~name_links: true versions_and_params];
                    (
                      let%lwt all_kinds =
                        List.sort_uniq Kind.Base.compare %
                          NEList.to_list
                        <$> NEList.map_lwt_p (Version.kind' % fst) versions_and_params
                      in
                      lwt [
                        txt @@
                          match all_kinds with
                          | [kind] -> Kind.Base.to_string kind ^ (if NEList.is_singleton versions_and_params then "" else "s")
                          | _ -> "Medley"
                      ]
                    );
                    lwt [Formatters.Version.composers_and_arrangers' ~short: true versions_and_params]
                  ]
                )
              | Book.Set (set, params) ->
                (
                  Tables.clickable_row [
                    lwt [txt "Set"];
                    lwt [
                      Formatters.Set.name' ~context ~params set;
                      br ();
                      small ~a: [a_class ["opacity-50"]] [Formatters.Set.tunes' ~link: true set];
                    ];
                    lwt [txt @@ Kind.Dance.to_string @@ Set.kind' set];
                    lwt [Formatters.Set.conceptors' ~short: true ~params set];
                  ]
                )
            )
            contents
        )
    ]

open Html

let create ?context id =
  Main_page.madge_call_or_404 (Book Get) id @@ fun book ->
  Page.make'
    ~parent_title: "Book"
    ~before_title: [
      Components.Context_links.make_and_render
        ?context
        ~this_page: (Endpoints.Page.href_book id)
        (lwt @@ Any.book book);
    ]
    ~title: (lwt @@ NEString.to_string @@ Book.title' book)
    ~subtitles: [Formatters.Book.date_and_editors' book]
    ~share: (Book book)
    ~actions: (
      lwt @@
      [Button.make
        ~label: "Download PDF"
        ~icon: (Other File_pdf)
        ~onclick: (fun _ -> ignore <$> Book_download_dialog.create_and_open book)
        ~dropdown: true
        ();
      Button.make_a
        ~label: "Edit"
        ~icon: (Action Edit)
        ~href: (S.const @@ Endpoints.Page.(href Book_edit) id)
        ~dropdown: true
        ();
      Action.delete
        ~model: "book"
        ~onclick: (fun () -> Madge_client.call Endpoints.Api.(route @@ Book Delete) (Entry.id book))
        ();
      ] @ (
        match Book.scddb_id' book with
        | None -> []
        | Some scddb_id -> [Action.scddb Publication scddb_id]
      )
    )
    [
      R.div
        (
          S.from' [] @@
            match%lwt Book.warnings book with
            | [] -> lwt_nil
            | warnings -> lwt [div ~a: [a_class ["alert"; "alert-warning"]] [ul ~a: [a_class ["mb-0"]] (display_warnings warnings)]]
        );
      div
        ~a: [a_class ["section"]]
        [
          h3 [txt "Contents"];
          R.div (
            S.from' (Tables.placeholder ()) @@
              let%lwt contents = Book.contents' book in
              lwt [table_contents ~this_id: id contents]
          )
        ];
    ]
