open Nes
open Js_of_ocaml
open Dancelor_common
open Dancelor_client_components
open Dancelor_client_model
module Formatters = Dancelor_client_formatters

let js = Js.string

type t =
  {
    page : Dancelor_client_elements.Page.t;
    content : Dom_html.divElement Js.t;
  }

let display_warnings warnings =
  let open Dancelor_client_html in
  let display_times n =
    if n = 1 then []
    else [txt " ("; txt (Int.to_english_string_times n); txt ")"]
  in
  let rec display_sets = function
    | [] -> []
    | (None, n) :: tl ->
      ([txt "standalone"] @ display_times n)
      :: display_sets tl
    | (Some set, n) :: tl ->
      ([txt "in â€œ";
        L.span (Formatters.Set.name set);
        txt "â€"] @ display_times n)
      :: display_sets tl
  in
  let rec format_set_list = function
    (* If the warning DuplicateVersion has been logged, the list of sets,
       and hence of html nodes generated by [display_sets] above is never empty *)
    | [] -> assert false
    | [hd] -> hd @ [txt "."]
    | hd::tl -> hd @ [txt ", "] @ format_set_list tl
  in
  let display_warning warning =
    match warning with
    | Book.Empty ->
      li [txt "This book does not contain any set"]
    | Book.DuplicateSet set ->
      li [
        txt "Set â€œ";
        L.span (Formatters.Set.name set);
        txt "â€ appears several times in this book."
      ]
    | Book.DuplicateVersion (tune, sets_opt) ->
      li (
        txt "Tune â€œ"
        :: L.span (Formatters.Tune.name tune)
        :: txt "â€ appears several times: "
        :: (display_sets sets_opt |> format_set_list)
      )
    | Book.SetDanceMismatch (set, dance) ->
      li [
        txt "Set â€œ";
        L.span (Formatters.Set.name set);
        txt "â€ does not have the same kind as its associated dance â€œ";
        L.span (Formatters.Dance.name dance);
        txt "â€."
      ]
  in
  List.map display_warning warnings

let table_contents contents =
  let open Dancelor_client_html in
  tablex
    ~a:[a_class ["separated-table"]]
    ~thead:(
      thead [
        tr [
          th [txt "Type"];
          th [txt "Name"];
          th [txt "Kind"];
        ]
      ]
    )
    [
      L.tbody (
        let%lwt contents = contents in
        List.map
          (function
            | Book.Set (set, parameters) ->
              (
                let slug = Set.slug set in
                let href =
                  let%lwt slug = slug in
                  Lwt.return PageRouter.(path (Set slug))
                in
                let open Lwt in
                Dancelor_client_tables.clickable_row ~href [
                  Lwt.return [txt "Set"];
                  (Formatters.Set.name_tunes_and_dance ~link:false set parameters);
                  Lwt.return [L.txt (Set.kind set >|= Kind.Dance.to_string)]
                ]
              )

            | InlineSet (set, parameters) ->
              (
                let open Lwt in
                tr [
                  td [txt "Set (inline)"];
                  L.td (Formatters.Set.name_tunes_and_dance ~link:false set parameters);
                  td [L.txt (Set.kind set >|= Kind.Dance.to_string)];
                ]
              )

            | Version (version, parameters) ->
              (
                let slug = Version.slug version in
                let href =
                  let%lwt slug = slug in
                  Lwt.return PageRouter.(path (Version slug))
                in
                Dancelor_client_tables.clickable_row ~href [
                  Lwt.return [txt "Tune"];
                  (Formatters.Version.name_and_dance ~link:false version parameters);
                  Lwt.return [L.txt (
                      let%lwt tune = Version.tune version in
                      let%lwt kind = Tune.kind tune in
                      let%lwt bars = Version.bars version in
                      let kind = (bars, kind) in
                      Lwt.return (Kind.Version.to_string kind)
                    )];
                ]
              )
          )
          contents
        |> Lwt.return
      )
    ]

let create slug page =
  let document = Dancelor_client_elements.Page.document page in
  let content = Dom_html.createDiv document in
  let book_lwt = Book.get slug in

  Lwt.async (fun () ->
      let%lwt book = book_lwt in
      let%lwt title = Book.title book in
      document##.title := js (title ^ " | Book | Dancelor");
      Lwt.return ()
    );

  let open Dancelor_client_html in

  let (pdf_dialog, show_pdf_dialog) =
    let booklet_parameters =
      BookParameters.(
        make
          ~front_page:true
          ~table_of_contents:End
          ~two_sided:true
          ~every_set:SetParameters.(
              make
                ~forced_pages:2
                ()
            )
          ()
      )
    in
    let bass_parameters =
      BookParameters.(
        make ~every_set:SetParameters.(
            make ~every_version:VersionParameters.(
                make
                  ~clef:Music.Bass
                  ~transposition:(Relative(Music.pitch_c, Music.make_pitch C Natural (-1)))
                  ()
              )
              ()
          )
          ()
      )
    in
    let b_parameters = BookParameters.make_instrument (Music.make_pitch B Flat (-1)) in
    let e_parameters = BookParameters.make_instrument (Music.make_pitch E Flat 0) in
    let c_pdf_href,         b_pdf_href,         e_pdf_href,         bass_pdf_href,
        c_booklet_pdf_href, b_booklet_pdf_href, e_booklet_pdf_href, bass_booklet_pdf_href =
      ApiRouter.(path @@ bookPdf slug @@ Option.none),
      ApiRouter.(path @@ bookPdf slug @@ Option.some @@                           b_parameters),
      ApiRouter.(path @@ bookPdf slug @@ Option.some @@                           e_parameters),
      ApiRouter.(path @@ bookPdf slug @@ Option.some @@                        bass_parameters),
      ApiRouter.(path @@ bookPdf slug @@ Option.some @@                                        booklet_parameters),
      ApiRouter.(path @@ bookPdf slug @@ Option.some @@ BookParameters.compose    b_parameters booklet_parameters),
      ApiRouter.(path @@ bookPdf slug @@ Option.some @@ BookParameters.compose    e_parameters booklet_parameters),
      ApiRouter.(path @@ bookPdf slug @@ Option.some @@ BookParameters.compose bass_parameters booklet_parameters)
    in
    let pdf_button href text =
      a ~a:[a_class ["button"]; a_href href; a_target "blank"] [
        i ~a:[a_class ["fas"; "fa-file-pdf"]] [];
        txt (" " ^ text)
      ]
    in
    ModalBox.make [
      h2 ~a:[a_class ["title"]] [txt "Download a PDF"];
      pdf_button c_pdf_href    "PDF";
      pdf_button b_pdf_href    "PDF (Bâ™­)";
      pdf_button e_pdf_href    "PDF (Eâ™­)";
      pdf_button bass_pdf_href "PDF (ð„¢)";
      br ();
      pdf_button c_booklet_pdf_href    "PDF (book)";
      pdf_button b_booklet_pdf_href    "PDF (Bâ™­, book)";
      pdf_button e_booklet_pdf_href    "PDF (Eâ™­, book)";
      pdf_button bass_booklet_pdf_href "PDF (ð„¢, book)";
    ]
  in

  (
    Dom.appendChild content @@ To_dom.of_div @@ div [
      h2 ~a:[a_class ["title"]] [L.txt (book_lwt >>=| Book.title)];
      h3 ~a:[a_class ["title"]] [L.txt (book_lwt >>=| Book.subtitle)];
      L.div (
        match%lwt book_lwt >>=| Book.scddb_id with
        | None -> Lwt.return_nil
        | Some scddb_id ->
          let href = SCDDB.list_uri scddb_id in
          Lwt.return [
            h3 ~a:[a_class ["title"]] [
              a ~a:[a_href href; a_target "blank"] [
                txt "Link to the Strathspey Database"
              ]
            ]
          ]
      );

      L.div (
        match%lwt book_lwt >>=| Book.warnings with
        | [] -> Lwt.return []
        | warnings -> Lwt.return [div ~a:[a_class ["warning"]] [ul (display_warnings warnings)]]
      );

      p [
        L.txt (
          let%lwt book = book_lwt in
          let%lwt date = Book.date book in
          match date with
          | None -> Lwt.return ""
          | Some date -> Lwt.return (spf "Date: %s" (NesPartialDate.to_pretty_string date))
        )
      ];

      pdf_dialog;
      div ~a:[a_class ["buttons"]] [
        a
          ~a:[
            a_class ["button"];
            a_onclick (fun _ -> show_pdf_dialog (); false);
          ]
          [
            i ~a:[a_class ["fas"; "fa-file-pdf"]] [];
            txt " PDF";
          ];

        a
          ~a:[
            a_class ["button"];
            a_href PageRouter.(path (BookEdit slug))
          ]
          [
            i ~a:[a_class ["fas"; "fa-edit"]] [];
            txt " Edit"
          ]
      ];

      div ~a:[a_class ["section"]] [
        h3 [txt "Contents"];

        table_contents (Lwt.bind book_lwt Book.contents)
      ];
    ]);

  {page; content}

let contents t =
  t.content

let init t =
  ignore t

let refresh t =
  ignore t
