open Nes
open Js_of_ocaml
open Dancelor_client_elements
open Dancelor_client_model
open Dancelor_common
module Formatters = Dancelor_client_formatters

let js = Js.string

type t =
  {
    page : Page.t;
    content : Dom_html.divElement Js.t;
    table : Table.t;
  }

let display_warnings warnings =
  let open Dancelor_client_html in
  let display_times n =
    if n = 1 then []
    else [text " ("; text (Int.to_english_string_times n); text ")"]
  in
  let rec display_sets = function
    | [] -> []
    | (None, n) :: tl ->
      ([text "standalone"] @ display_times n)
      :: display_sets tl
    | (Some set, n) :: tl ->
      ([text "in “"; span_lwt (Formatters.Set.name set); text "”"] @ display_times n)
      :: display_sets tl
  in
  let rec format_set_list = function
    (* If the warning DuplicateVersion has been logged, the list of sets,
       and hence of html nodes generated by [display_sets] above is never empty *)
    | [] -> assert false
    | [hd] -> hd @ [text "."]
    | hd::tl -> hd @ [text ", "] @ format_set_list tl
  in
  let display_warning warning =
    match warning with
    | Book.Empty ->
      li [text "This book does not contain any set"]
    | Book.DuplicateSet set ->
      li [
        text "Set “";
        span_lwt (Formatters.Set.name set);
        text "” appears several times in this book."
      ]
    | Book.DuplicateVersion (tune, sets_opt) ->
      li (
        text "Tune “"
        :: span_lwt (Formatters.Tune.name tune)
        :: text "” appears several times: "
        :: (display_sets sets_opt |> format_set_list)
      )
  in
  List.map display_warning warnings

let display_contents t contents =
  let rows =
    List.map
      (function
        | Book.Set (set, parameters) ->
          (
            let slug = Set.slug set in
            let href =
              let%lwt slug = slug in
              Lwt.return (Router.path_of_controller (Router.Set slug) |> snd)
            in
            let cells =
              let open Lwt in
              [
                Table.Cell.text ~text:(Lwt.return "Set") t.page;
                Table.Cell.create ~content:(
                  let%lwt content = Formatters.Set.name_tunes_and_dance set parameters in
                  Lwt.return (Dancelor_client_html.nodes_to_dom_nodes (Page.document t.page) content)
                ) t.page;
                Table.Cell.text ~text:(Set.kind set >|= Kind.dance_to_string) t.page
              ]
            in
            Table.Row.create ~href ~cells t.page
          )

        | InlineSet (set, parameters) ->
          (
            let cells =
              let open Lwt in [
                Table.Cell.text ~text:(Lwt.return "Set (inline)") t.page;
                Table.Cell.create ~content:(
                  let%lwt content = Formatters.Set.name_tunes_and_dance set parameters in
                  Lwt.return (Dancelor_client_html.nodes_to_dom_nodes (Page.document t.page) content)
                ) t.page;
                Table.Cell.text ~text:(Set.kind set >|= Kind.dance_to_string) t.page
              ]
            in
            Table.Row.create ~cells t.page
          )

        | Version (version, parameters) ->
          (
            let slug = Version.slug version in
            let href =
              let%lwt slug = slug in
              Lwt.return (Router.path_of_controller (Router.Version slug) |> snd)
            in
            let cells = [
                Table.Cell.text ~text:(Lwt.return "Tune") t.page;
                Table.Cell.create ~content:(
                  let%lwt content = Formatters.Version.name_and_dance version parameters in
                  Lwt.return (Dancelor_client_html.nodes_to_dom_nodes (Page.document t.page) content)
                ) t.page;
                Table.Cell.text ~text:(
                  let%lwt tune = Version.tune version in
                  let%lwt kind = Tune.kind tune in
                  let%lwt bars = Version.bars version in
                  let kind = (bars, kind) in
                  Lwt.return (Kind.version_to_string kind)
                ) t.page
              ]
            in
            Table.Row.create ~href ~cells t.page
          )
      )
      contents
    |> Lwt.return
  in
  let section = Table.Section.create ~rows t.page in
  Table.replace_bodies t.table (Lwt.return [section])

let create slug page =
  let document = Page.document page in
  let content = Dom_html.createDiv document in
  let book_lwt = Book.get slug in

  Lwt.async (fun () ->
      let%lwt book = book_lwt in
      let%lwt title = Book.title book in
      document##.title := js (title ^ " | Book | Dancelor");
      Lwt.return ()
    );


  let header =
    Table.Row.create
      ~cells:[
        Table.Cell.header_text ~text:(Lwt.return "Type") page;
        Table.Cell.header_text ~text:(Lwt.return "Name") page;
        Table.Cell.header_text ~text:(Lwt.return "Kind") page;
      ]
      page
  in
  let ttable = Table.create
      ~header
      ~kind:Table.Kind.Separated
      page
  in

  Dancelor_client_html.(append_nodes (content :> dom_node) (Page.document page) [
      h2 ~classes:["title"] [ text_lwt (book_lwt >>=| Book.title) ];
      h3 ~classes:["title"] [ text_lwt (book_lwt >>=| Book.subtitle) ];

      div_lwt
        (* Only open a warnings div if there are warnings *)
        (match%lwt book_lwt >>=| Book.warnings with
        | [] -> Lwt.return []
        | warnings -> Lwt.return [div ~classes:["warning"] [ul (display_warnings warnings)]]);

      p [ text_lwt (
          let%lwt book = book_lwt in
          let%lwt date = Book.date book in
          if Date.is_none date then
            Lwt.return ""
          else
            Lwt.return (spf "Date: %s" (NesDate.to_string date))
        ) ];

      div ~classes:["buttons"] (
        let booklet_parameters =
          BookParameters.(
            make
              ~front_page:true
              ~table_of_contents:End
              ~two_sided:true
              ~every_set:SetParameters.(
                  make
                    ~forced_pages:2
                    ()
                )
              ()
          )
        in
        let bass_parameters =
          BookParameters.(
            make ~every_set:SetParameters.(
                make ~every_version:VersionParameters.(
                    make
                      ~clef:Music.Bass
                      ~transposition:(Relative(Music.pitch_c, Music.make_pitch C Natural (-1)))
                      ()
                  )
                  ()
              )
              ()
          )
        in
        let b_parameters = BookParameters.make_instrument (Music.make_pitch B Flat (-1)) in
        let e_parameters = BookParameters.make_instrument (Music.make_pitch E Flat 0) in

        let c_pdf_href, b_pdf_href, e_pdf_href, bass_pdf_href,
            c_booklet_pdf_href, b_booklet_pdf_href, e_booklet_pdf_href, bass_booklet_pdf_href =
          Helpers.build_path ~api:true ~route:(Router.BookPdf slug)
            (),
          Helpers.build_path ~api:true ~route:(Router.BookPdf slug)
            ~query:["parameters", [
                b_parameters
                |> BookParameters.to_yojson |> Yojson.Safe.to_string
              ]] (),
          Helpers.build_path ~api:true ~route:(Router.BookPdf slug)
            ~query:["parameters", [
                e_parameters
                |> BookParameters.to_yojson |> Yojson.Safe.to_string
              ]] (),
          Helpers.build_path ~api:true ~route:(Router.BookPdf slug)
            ~query:["parameters", [
                bass_parameters
                |> BookParameters.to_yojson |> Yojson.Safe.to_string
              ]] (),
          Helpers.build_path ~api:true ~route:(Router.BookPdf slug)
            ~query:["parameters", [
                booklet_parameters
                |> BookParameters.to_yojson |> Yojson.Safe.to_string
              ]] (),
          Helpers.build_path ~api:true ~route:(Router.BookPdf slug)
            ~query:["parameters", [
                BookParameters.(
                  compose b_parameters booklet_parameters
                  |> to_yojson |> Yojson.Safe.to_string
                )
              ]] (),
          Helpers.build_path ~api:true ~route:(Router.BookPdf slug)
            ~query:["parameters", [
                BookParameters.(
                  compose e_parameters booklet_parameters
                  |> to_yojson |> Yojson.Safe.to_string
                )
              ]] (),
          Helpers.build_path ~api:true ~route:(Router.BookPdf slug)
            ~query:["parameters", [
                BookParameters.(
                  compose bass_parameters booklet_parameters
                  |> to_yojson |> Yojson.Safe.to_string
                )
              ]] ()
        in
        let c_pdf, b_pdf, e_pdf, bass_pdf,
            c_booklet_pdf, b_booklet_pdf, e_booklet_pdf, bass_booklet_pdf =
          Inputs.Button.create ~href:(Lwt.return c_pdf_href) ~icon:"file-pdf" ~text:"PDF" page,
          Inputs.Button.create ~href:(Lwt.return b_pdf_href) ~icon:"file-pdf" ~text:"PDF (B♭)" page,
          Inputs.Button.create ~href:(Lwt.return e_pdf_href) ~icon:"file-pdf" ~text:"PDF (E♭)" page,
          Inputs.Button.create ~href:(Lwt.return bass_pdf_href) ~icon:"file-pdf" ~text:"PDF (𝄢)" page,
          Inputs.Button.create ~href:(Lwt.return c_booklet_pdf_href) ~icon:"file-pdf" ~text:"PDF (book)" page,
          Inputs.Button.create ~href:(Lwt.return b_booklet_pdf_href) ~icon:"file-pdf" ~text:"PDF (B♭, book)" page,
          Inputs.Button.create ~href:(Lwt.return e_booklet_pdf_href) ~icon:"file-pdf" ~text:"PDF (E♭, book)" page,
          Inputs.Button.create ~href:(Lwt.return bass_booklet_pdf_href) ~icon:"file-pdf" ~text:"PDF (𝄢, book)" page
        in

        [
          node_of_dom_node (Inputs.Button.root c_pdf :> dom_node);
          node_of_dom_node (Inputs.Button.root b_pdf :> dom_node);
          node_of_dom_node (Inputs.Button.root e_pdf :> dom_node);
          node_of_dom_node (Inputs.Button.root bass_pdf :> dom_node);
          br;
          node_of_dom_node (Inputs.Button.root c_booklet_pdf :> dom_node);
          node_of_dom_node (Inputs.Button.root b_booklet_pdf :> dom_node);
          node_of_dom_node (Inputs.Button.root e_booklet_pdf :> dom_node);
          node_of_dom_node (Inputs.Button.root bass_booklet_pdf :> dom_node);
        ]
      );

      div ~classes:["section"] [
        h3 [ text "Contents" ];

        node_of_dom_node (Table.root ttable :> dom_node)
      ]
    ]);

  let t = {page; content; table=ttable} in
  Lwt.on_success book_lwt (fun prog -> Lwt.on_success (Book.contents prog) (display_contents t));
  t

let contents t =
  t.content

let init t =
  ignore t

let refresh t =
  ignore t
